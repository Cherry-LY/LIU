#include <stdio.h>
#include <stdlib.h>
/*中值滤波是对一个滑动窗口内的值进行排序，用其中值代替窗口中心点的原来值的滤波方法，它在抑制随机噪声的同时能有效保护原有信息。以一维信号的中值滤波举例。

对序列 80 120 90 200 100 110 150，假设滤波窗口宽度为5,那么有

滤波窗口的子序列

子序列排序

待替换的值

序列中值

80 120 90 200 100

80 90 10O 120 200

90

100

120 90 200 100 110

90 100 110 120 200

200

110

90 200 100 110 150

90 100 110 150 200

100

110

滤波窗口的值如果不够5个值那么不改变对应点的值， 比如左侧的80， 以它为中心的5个长度的窗口内没有5个数，所以这个点仍然是80不变。

所以最后滤波结果是80 120 100 110 110 110 150。

如果滤波窗口宽度为3，那么滤波结果是80 90 120 100 110 110 150。

 

输入

 

可能包含多组数据。每组数据包括2行。第一行为2个整数w、n，w为滤波窗口宽度（必须是奇数），n表示后面有n个整数。第二行为待滤波的n个整数，各数之间用一个空格来间隔。

 

输出

 

输出滤波后的序列，各数之间用一个空格分隔，输出需占一行，结尾需换行。如果输入w不是奇数那么输出ERROR。

 

样例

 

输入

输出

3 5

1 3 9 2 8

5 5

1 3 9 2 8

4 5

1 3 9 2 8

1 3 3 8 8

1 3 3 2 8

ERROR*/



int main(int argc, char *argv[]) {
	int w,n,i,a[20],b[20],c[20],k,t,m,j,x;
	char ch;
	while(ch!=EOF)
	{
	scanf("%d %d",&w,&n);
		for(i=0;i<n;i++)
		{
			scanf("%d",&a[i]);
			b[i]=a[i];
			c[i]=a[i];
		}
	if(w%2==0) printf("ERROR\n");
	else
	{
		for(i=0;i<=n-w;i++)
		{
		for(x=0;x<n;x++)
		{
			a[x]=c[x];
		}
		for(j=i;j<i+w;j++)
		{
			for(k=i;k<j;k++)
			{
			if(a[k]>a[j])
		    {t=a[k];
		    a[k]=a[j];
		    a[j]=t;
		    }
			}
		}
		m=i+(w-1)/2;
		b[m]=a[m];
		}
		for(j=0;j<n;j++)
		{printf("%d ",b[j]);
		}
		printf("\n");		
	}
	ch=getchar();
}
    return 0;
}

